# 算法知识
## 数组
在数组中间插入和删除的操作性能较低，但是因为数组可以根据下标值去取元素、修改元素，效率很高。<br>
链表插入和删除的性能不错，但是查找元素非常慢，是通过线性查找。

## 栈结构
先进后出。只能在一端添加删除元素。<br>
函数调用栈。递归就是不断的调用自己，容易出现栈溢出的错误。

![函数调用栈](/docs/codeExample/learn/Image/callStack.png)

### 栈结构封装
#### 基于数组实现
#### 基于链表实现

<<< @/docs/codeExample/learn/stackmManipulation.vue

#### 栈的操作
##### push()
##### pop()
##### peek()：返回栈顶的元素，不对栈做任何修改(不会对栈做修改，仅仅返回值)。
##### isEmpty()：如果栈里没有任何元素就返回true，否则返回false。
##### size()：返回栈里的元素个数。这个方法和数组的length属性很类似。
##### toString()：将栈结构的内容以字符形式返回。

###  利用栈十进制转二进制

在使用 console.log 进行打印的时候，栈的 pop 也会进行执行，从而影响栈里面的元素<br>

中缀表达式（或中缀记法）是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例：3 + 4），中缀表达式是人们常用的算术表示方法。<br>

与前缀表达式（例：+ 3 4）或后缀表达式（例：3 4 +）相比，中缀表达式不容易被计算机解析，但仍被许多程序语言使用，因为它符合人们的普遍用法。<br>

与前缀或后缀记法不同的是，中缀记法中括号是必需的。计算过程中必须用括号将操作符和对应的操作数括起来，用于指示运算的次序。<br>

例：<br>
（1）8+4-6*2用后缀表达式表示为：<br>
8 4+6 2*-<br>

（2）2*（3+5）+7/1-4用后缀表达式表示为：<br>
235+*71/+4-<br>

## 队列
先进先出。只允许在前端进行删除操作，在后端进行新增操作。<br>

同栈结构，队列也有两种实现方法，一种是基于数组，一种是基于链表。基于链表的性能相对更高一点。

### 队列常见操作
#### enqueue(ele)：向队列尾部添加一个（或多个）新的项
#### dequeue()：移出队列的第一项，并返回被移除的元素
#### front()：返回队列的第一个元素。（不会造成队列元素发生改变）
#### isEmpty()：队列中不包含任何元素，返回true，否则返回false
#### size()：队列里包含的元素个数
#### toString()：将队列中的内容，转成字符的形式

### 优先级队列
优先级队列，在插入一个元素的时候会考虑该数据的优先级。和其它数据优先级进行比较。<br>
优先级队列需要考虑的问题：<br>
（1）每个元素不再只是一个数据，而是包含数据的优先级。<br>
（2）在添加方式中，根据优先级放入正确的位置。<br>

每一个数据项不仅要包含它的数据，而且要包含这个数据的优先级。

## 链表
数组的创建通常需要申请一顿连续的内存空间，并且大小是固定的。所以当当前数组不能满足容量需求时，需要扩容（一般情况是申请一个更大的数组，比如2倍，然后将原数组中的元素复制过去）<br>

不同于数组，链表中的元素在内存中不必是连续的空间。链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针/连接）组成。<br>

链表的优点：<br>
（1）内存空间不是连续的--可以动态的插入值<br>
（2）不必在创建时就确定大小--可以无限的延伸下去<br>
（3）在插入和删除数时，时间复杂度可以达到O(1)，相对数组效率高很多

链表的缺点：<br>
访问任何元素都需要从头开始访问，无法通过下标值进行元素的快速访问。 

### 链表常见的操作
#### append(ele)：向链表尾部添加一个新的项
#### inser(position,ele)：向链表的特定位置插入一个新的项
#### get(position)：获取对应位置的元素
#### indexOf(ele)：返回元素在列表中的索引，如果链表里没有该元素则返回-1
#### update(position)：修改某个位置的元素
#### removeAt(position)：删除某个位置的元素
#### remove(ele)：从链表里移除某一项
#### isEmpty()
#### size()
#### toString()